# Problem 050: Consecutive prime sum

## 問題文

素数41は、6つの連続する素数の和で表すことができます：

41 = 2 + 3 + 5 + 7 + 11 + 13

これは100未満の素数を連続する素数の和で表したときに最長のものです。

素数953は21個の連続する素数の和で表すことができます。

100万未満の素数で、最も多くの連続する素数の和で表せるものはどれでしょうか？

## アプローチ

### 1. 素直な解法 (solve_naive)

**基本的な考え方:**
- 全ての可能な連続する素数の組み合わせを生成
- それらの和が素数かどうかを確認
- 最も長い連続和を見つける

**アルゴリズム:**
1. エラトステネスの篩で上限以下の全素数を生成
2. 各開始位置から連続する素数の和を計算
3. 和が素数で最長の場合を記録

**時間計算量:** O(n² × √max_sum)
**空間計算量:** O(n)

### 2. 最適化解法 (solve_optimized)

**改善点:**
- 累積和を事前計算して、連続する素数の和をO(1)で計算

**アルゴリズム:**
1. 素数列の累積和を事前計算
2. 任意の区間の和を累積和の差で高速計算
3. 各区間の和が素数かどうかを確認

**時間計算量:** O(n²)
**空間計算量:** O(n)

### 3. 数学的解法 (solve_mathematical)

**数学的洞察:**
- 最大長の連続和から降順で探索することで効率化
- 長い連続和が見つかった時点で探索を終了

**アルゴリズム:**
1. 累積和を事前計算
2. 最大可能長から降順で連続和の長さを試行
3. 指定した長さで素数となる連続和が見つかれば終了

**時間計算量:** O(n²) (実際は早期終了により高速)
**空間計算量:** O(n)

## 重要な最適化

### エラトステネスの篩
```python
def sieve_of_eratosthenes(limit: int) -> List[int]:
    if limit < 2:
        return []

    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False

    for i in range(2, int(limit**0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, limit + 1, i):
                is_prime[j] = False

    return [i for i in range(2, limit + 1) if is_prime[i]]
```

### 累積和による高速化
```python
# 累積和を事前計算
cumulative_sum = [0]
for prime in primes:
    cumulative_sum.append(cumulative_sum[-1] + prime)

# 区間 [start, end] の和を O(1) で計算
current_sum = cumulative_sum[end + 1] - cumulative_sum[start]
```

## アルゴリズムの比較

| 解法 | 時間計算量 | 空間計算量 | 特徴 |
|------|------------|------------|------|
| 素直な解法 | O(n² × √max_sum) | O(n) | 基本的な実装 |
| 最適化解法 | O(n²) | O(n) | 累積和による高速化 |
| 数学的解法 | O(n²) | O(n) | 早期終了による効率化 |

## 学習ポイント

1. **エラトステネスの篩**: 大量の素数を効率的に生成
2. **累積和**: 区間和の高速計算テクニック
3. **素数判定**: 平方根までの試行除算による効率化
4. **探索の最適化**: 降順探索による早期終了
5. **数学的洞察**: 問題の性質を利用した効率化

## 実装上の注意点

- 大きな数の素数判定には計算時間がかかるため、事前に素数集合を作成
- 累積和のオーバーフローに注意（Pythonでは自動的に多倍長整数）
- メモリ使用量と計算時間のトレードオフを考慮

## 検証

### 小さな例での確認
- 100未満: 41 = 2 + 3 + 5 + 7 + 11 + 13 (6つの連続する素数)
- 1000未満: より長い連続和が存在することを確認

### テストケース
- 境界値テスト（上限1, 2など）
- 中間値での解法間一致性
- 結果が素数であることの確認

## 解答

Project Euler公式サイトで確認してください。

## 検証結果
- **入力:** 100万未満の素数
- **解答:** [隠匿]
- **検証:** ✓ (全解法で一致)
- **連続する素数の個数:** [隠匿]個
