# Problem 029: Distinct powers

## 問題

2 ≤ a ≤ 100 と 2 ≤ b ≤ 100 について、a^b で生成される異なる項の個数を求めなさい。

## 解答

Project Euler公式サイトで確認してください。

## 解法

この問題は、指定された範囲の `a` と `b` について `a^b` を計算し、その結果として現れるユニークな値の数を数えるものです。

### 素直な解法 (`solve_naive`)

Pythonの強力な多倍長整数サポートと効率的な `set` データ構造を活用するのが、この問題に対する最も直接的で、かつ十分に高性能なアプローチです。

- **アルゴリズム**:
  1. 空の `set` を初期化します。
  2. `a` を 2 から 100 までループさせます。
  3. 内側のループで `b` を 2 から 100 までループさせます。
  4. `a**b` の結果を `set` に追加します。`set` は自動的に重複を処理してくれます。
  5. すべてのループが終わった後、`set` のサイズ（要素数）を返します。これが答えとなります。

- **時間計算量**: `O(n^2 * log(b_max))` (nは範囲の上限)。`a**b` の計算時間は `b` の対数に比例します。
- **空間計算量**: `O(n^2)`。最悪の場合、すべての結果がユニークであると仮定すると、`set` は約 `n^2` 個の要素を格納します。

```python
def solve_naive(limit: int = 100) -> int:
    """
    Generates all a^b and counts the number of distinct terms using a set.
    """
    distinct_terms = set()
    for a in range(2, limit + 1):
        for b in range(2, limit + 1):
            distinct_terms.add(a**b)
    return len(distinct_terms)
```

### 最適化について

この問題では、`4^2 = 16` と `2^4 = 16` のように、異なる `a` と `b` の組み合わせが同じ結果を生むことがあります。これを数学的に解決するには、各 `a` を素因数分解し、`a = p_1^{e_1} * p_2^{e_2} * ...` の形で表現します。すると `a^b = p_1^{e_1*b} * p_2^{e_2*b} * ...` となり、この素因数分解表現がユニークかどうかを判定することになります。

しかし、このアプローチは実装がかなり複雑になります。Pythonでは、`set` を使ったハッシュベースの重複排除が非常に高速なため、わざわざ素因数分解を用いた最適化を行う実用上のメリットはほとんどありません。そのため、今回は素直な解法をそのまま最適解として採用しています。

## 学習ポイント

- Pythonの `set` データ構造の効率性と、重複排除における有用性を再確認する。
- 問題の制約（`a, b <= 100`）から、計算量の見積もりを行い、素直なブルートフォースアプローチが許容範囲内であるかを判断する能力。
- 理論的な最適化（素因数分解）と、言語の特性を活かした実用的な解法（`set`の利用）のトレードオフを理解する。
