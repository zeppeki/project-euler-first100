# Problem 055: Lychrel numbers

## 問題文

47を取り、逆順にして足すと、47 + 74 = 121となり、これは回文数である。

すべての数が素早く回文数になるわけではない。例えば、

349 + 943 = 1292,
1292 + 2921 = 4213
4213 + 3124 = 7337

つまり、349は3回の反復で回文数に到達した。

まだ証明されていないが、196のような数は決して回文数を生成しないと考えられている。逆順にして足すプロセスで決して回文数を形成しない数をLychrel数と呼ぶ。これらの数の理論的性質のため、そしてこの問題の目的のため、数が Lychrel数であることが証明されるまで、そうでないものとする。

さらに、10,000未満のすべての数について、(i) 50回未満の反復で回文数になるか、(ii) これまでに存在するすべての計算能力をもってしても、誰もそれを回文数にマップすることに成功していない、のいずれかである。実際、10677は回文数を生成するのに50回を超える反復を必要とすることが示された最初の数である：4668731596684224866951378664（53回の反復、28桁）。

驚くべきことに、それ自体がLychrel数である回文数が存在する。最初の例は4994である。

10,000未満にLychrel数はいくつあるか？

## アプローチ

### アプローチ 1: 素直な解法 (solve_naive)

**アルゴリズム**:
1. 1から limit-1 まですべての数値を調べる
2. 各数値について反転加算プロセスを最大50回実行
3. 50回以内に回文数にならなければLychrel数とカウント

**計算量**:
- 時間計算量: O(n × k × log m) where n=数値の範囲, k=50回, m=最大数値
- 空間計算量: O(1)

**実装のポイント**:
- `is_palindrome()`: 数値を文字列に変換して逆順と比較
- `reverse_number()`: 数値を文字列にして逆順に並べ替え後、整数に変換
- `is_lychrel_number()`: 反転加算プロセスを最大50回実行

### アプローチ 2: 最適化解法 (solve_optimized)

**最適化のポイント**:
1. **回文数の特別扱い**: すでに回文数の場合、1回の反転加算で判定
2. **早期終了**: 回文数が見つかり次第すぐに終了

**アルゴリズム**:
1. 数値が既に回文数かチェック
2. 回文数の場合: 1回の反転加算で回文数になるかチェック
3. 非回文数の場合: 通常の反転加算プロセスを実行

**計算量**:
- 時間計算量: O(n × k × log m) - 平均的には改善
- 空間計算量: O(1)

## 重要な概念

### Lychrel数の特徴

1. **定義**: 反転加算プロセスで回文数にならない数
2. **判定基準**: 50回以内に回文数にならない数をLychrel数とする
3. **既知のLychrel数**: 196, 295, 394, 493, 592, 689, 691, 788, 790, 879, 887, 978, 986など
4. **回文数のLychrel数**: 4994などの例外的なケース

### 反転加算プロセス

**例1: 47の場合**
```
47 + 74 = 121 (回文数) → 1回で完了
```

**例2: 349の場合**
```
349 + 943 = 1292
1292 + 2921 = 4213
4213 + 3124 = 7337 (回文数) → 3回で完了
```

**例3: 196の場合（Lychrel数）**
```
196 + 691 = 887
887 + 788 = 1675
1675 + 5761 = 7436
... (50回繰り返しても回文数にならない)
```

## 実装上の注意点

### エッジケース

1. **単一桁の数**: すべて回文数だが、反転加算で別の回文数になる可能性
2. **回文数のLychrel数**: 4994のように回文数でもLychrel数になる場合
3. **大きな数値**: 反復により数値が非常に大きくなる可能性

### パフォーマンス考慮

1. **文字列操作の最適化**: 回文数判定と数値反転で文字列変換を使用
2. **早期終了**: 回文数が見つかり次第すぐに終了
3. **メモリ効率**: 各数値を独立して処理し、追加のストレージを使用しない

## 学習ポイント

### 数学的洞察

1. **Lychrel数の分布**: 小さな数値に集中している傾向
2. **回文数の性質**: 多くの数値は数回の反復で回文数になる
3. **数値の成長**: 反復により数値が指数的に成長する可能性

### アルゴリズム設計

1. **反復プロセス**: 条件が満たされるまで操作を繰り返す
2. **文字列操作**: 数値の操作を文字列処理で実現
3. **判定基準**: 有限回数での近似的判定

## 実行例

### テストケース

```python
# 既知の非Lychrel数
assert not is_lychrel_number(47)   # 1回で回文数
assert not is_lychrel_number(349)  # 3回で回文数

# 既知のLychrel数
assert is_lychrel_number(196)      # 50回では回文数にならない
assert is_lychrel_number(4994)     # 回文数だがLychrel数
```

### 統計情報

- **範囲**: 1-9999
- **Lychrel数の個数**: [隠匿]
- **回文数のLychrel数**: 13個（4994, 8778, 9999など）

## 解答

Project Euler公式サイトで確認してください。

## 検証

- **入力**: limit = 10000
- **解答**: [隠匿]
- **検証**: ✓ 全解法で一致

## 参考文献

- **Lychrel数**: 数学的に興味深い数列の研究
- **回文数**: 数論における基本的な概念
- **反復アルゴリズム**: 条件収束型のアルゴリズム設計
