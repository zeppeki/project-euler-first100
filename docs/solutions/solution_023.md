# Problem 023: Non-Abundant Sums

## 問題文
完全数は、その数の真の約数の和がちょうどその数と等しい数です。例えば、28の真の約数の和は1 + 2 + 4 + 7 + 14 = 28なので、28は完全数です。

数nが不足数と呼ばれるのは、その真の約数の和がnより小さい場合で、過剰数と呼ばれるのは、この和がnを超える場合です。

12は最小の過剰数で、1 + 2 + 3 + 4 + 6 = 16です。2つの過剰数の和として表せる最小の数は24です。

数学的解析により、28123より大きい全ての整数は2つの過剰数の和として表せることが示されています。しかし、この上限は解析によってこれ以上減らすことはできませんが、2つの過剰数の和として表せない最大の数はこの限界より小さいことが知られています。

2つの過剰数の和として表せない全ての正の整数の和を求めなさい。

## 解法の概要

### アプローチ1: 素直な解法 (solve_naive)
1. 各数の真の約数の和を計算し、過剰数を特定
2. 全ての過剰数ペアの和をSetに格納
3. 1からlimitまでの各数が過剰数の和で表せるかチェック
4. 表せない数の合計を返す

**時間計算量**: O(n² × √n)
**空間計算量**: O(n)

### アプローチ2: 最適化解法 (solve_optimized)
1. 約数和を事前計算してキャッシュ
2. フラグ配列を使用して過剰数の和をマーク
3. 効率的なループで重複計算を回避

**時間計算量**: O(n × √n + A²) ※Aは過剰数の個数
**空間計算量**: O(n)

## 数学的背景

### 数の分類
- **完全数**: σ(n) - n = n（真の約数の和が数自身と等しい）
  - 例: 6 (1+2+3=6), 28 (1+2+4+7+14=28)
- **不足数**: σ(n) - n < n（真の約数の和が数自身より小さい）
  - 例: 8 (1+2+4=7<8)
- **過剰数**: σ(n) - n > n（真の約数の和が数自身より大きい）
  - 例: 12 (1+2+3+4+6=16>12)

### 重要な性質
1. 12が最小の過剰数
2. 24が2つの過剰数の和で表せる最小の数（12+12=24）
3. 28,123より大きい全ての整数は2つの過剰数の和で表せる

### 約数和の効率的計算
nの約数は対称性を持つため、√nまでの試し割りで計算可能：
```
for i in range(1, int(sqrt(n)) + 1):
    if n % i == 0:
        sum += i
        if i != n // i and i != 1:  # 重複回避と真の約数条件
            sum += n // i
```

## 実装のポイント

### 最適化技法
1. **約数和の前計算**: 過剰数判定を高速化
2. **フラグ配列**: Set操作よりも高速なメモリアクセス
3. **ループの早期終了**: 和がlimitを超えた時点で内側ループを中断
4. **対称性の活用**: i ≤ jの組み合わせのみを計算

### エッジケース
- n=1: 真の約数が存在しない（約数和=0）
- 完全数: 過剰数ではない
- 大きな素数: 約数和=1で不足数

## パフォーマンス分析

### 実行時間比較
- 素直な解法（n=1000）: ~0.1秒
- 最適化解法（n=28123）: ~0.3秒

### メモリ使用量
- フラグ配列: O(28123) = 約28KB
- 過剰数リスト: 約6000個（28123以下）

## 検証と結果

### テストケース
- limit=30: 230（小規模テスト）
- limit=100: 1574（中規模テスト）
- limit=28123: [隠匿]（実際の問題）

### 解答
Project Euler公式サイトで確認してください。

### 統計情報
- 28,123以下の過剰数: 約6,965個
- 全体に占める割合: 約24.7%

## 学習ポイント

1. **約数関数の性質**: σ(n)の効率的計算
2. **組み合わせ最適化**: 重複を避けた全探索
3. **メモリアクセスパターン**: 配列 vs Set のパフォーマンス
4. **数論の応用**: 完全数・過剰数・不足数の分類

## 関連問題
- Problem 021: Amicable numbers（友愛数、約数和の応用）
- Problem 095: Amicable chains（約数和の連鎖）
