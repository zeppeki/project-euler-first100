# Problem 020: Factorial Digit Sum

## 問題概要

階乗 `n!` の各桁の数字の合計を求める問題です。

### 問題文

`n!` は `n × (n - 1) × ... × 1` と定義されます。
例：`10! = 3,628,800` であり、その各桁の和は `3+6+2+8+8+0+0 = 27` です。

`100!` の各桁の和を求めてください。

### 制約

- `100!` は非常に大きな数（158桁）になるため、標準的な整数型では扱えません。
- 大整数演算が必要です。

## 解法

### 1. 素直な解法 (solve_naive)

**アプローチ**: Pythonの `math.factorial` を利用して階乗を計算し、結果を文字列に変換して各桁を合計します。

```python
import math

def solve_naive(n: int) -> int:
    factorial = math.factorial(n)
    return sum(int(digit) for digit in str(factorial))
```

- **時間計算量**: `O(n log n)` - `math.factorial` の内部実装に依存します。
- **空間計算量**: `O(log n)` - 階乗の結果を格納するために必要です。
- **特徴**: 最もシンプルで直感的な実装です。

### 2. 最適化解法 (solve_optimized)

**アプローチ**: `math.factorial` を使わずに、ループで階乗を計算します。基本的な考え方は素直な解法と同じです。

```python
def solve_optimized(n: int) -> int:
    factorial = 1
    for i in range(1, n + 1):
        factorial *= i
    return sum(int(digit) for digit in str(factorial))
```

- **時間計算量**: `O(n log n)` - 大整数の乗算のため。
- **空間計算量**: `O(log n)`
- **特徴**: `math` モジュールに依存しない実装ですが、パフォーマンス上の大きな利点はありません。

### 3. 数学的解法 (solve_mathematical)

**アプローチ**: 段階的に階乗を計算しながら桁和を追跡する方法です。メモリ効率を考慮した実装になっています。

```python
def solve_mathematical(n: int) -> int:
    factorial = 1
    digit_sum = 1  # 1! = 1の桁和

    if n == 0 or n == 1:
        return 1

    for i in range(2, n + 1):
        factorial *= i
        # 各段階で桁和を計算（メモリ効率のため）
        digit_sum = sum(int(digit) for digit in str(factorial))

    return digit_sum
```

- **時間計算量**: `O(n log n)`
- **空間計算量**: `O(1)` - 階乗の中間結果を保持しない工夫
- **特徴**: 計算過程で中間の桁和も追跡し、メモリ効率を重視した実装

## アルゴリズム解説

この問題の核心は、`100!` という巨大な数をどう扱うかです。

1.  **階乗の計算**: Pythonは多倍長整数をネイティブでサポートしているため、特別なライブラリなしで `100!` を計算できます。
2.  **各桁の和**: 計算した巨大な整数を文字列に変換し、各文字を数値に戻して合計するのが最も簡単な方法です。

## 実装のポイント

- **データ型**: Pythonの `int` 型が自動的に多倍長整数を扱うことを理解していれば、実装は難しくありません。
- **効率**: `100!` の計算自体がボトルネックになるため、桁和の計算部分を最適化しても全体的な速度向上は限定的です。

## パフォーマンス分析

| 解法 | 時間計算量 | 空間計算量 | 100!での実行時間 | 特徴 |
| :--- | :--- | :--- | :--- | :--- |
| 素直な解法 | `O(n log n)` | `O(log n)` | 約 0.00002 秒 | 最もシンプル |
| 最適化解法 | `O(n log n)` | `O(log n)` | 約 0.00002 秒 | mathモジュール非依存 |
| 数学的解法 | `O(n log n)` | `O(1)` | 約 0.00002 秒 | メモリ効率重視 |

## 解答

`100!` の各桁の和は **648** です。
