# Problem 015: Lattice paths

## 問題
20×20格子における左上から右下への最短経路の数を求めよ。

## 詳細
Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.

How many such routes are there through a 20×20 grid?

## 解答

Project Euler公式サイトで確認してください。

## 解法

### 1. 素直な解法 (Dynamic Programming - 2D)
```python
def solve_naive(n):
    # (n+1) × (n+1) のグリッドを作成
    grid = [[0] * (n + 1) for _ in range(n + 1)]

    # 上端と左端の経路数は全て1
    for i in range(n + 1):
        grid[0][i] = 1  # 上端
        grid[i][0] = 1  # 左端

    # 各点までの経路数を計算
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            grid[i][j] = grid[i-1][j] + grid[i][j-1]

    return grid[n][n]
```

**特徴:**
- 動的プログラミングで各点までの経路数を順次計算
- 各点での経路数 = 上からの経路数 + 左からの経路数
- 境界条件: 上端と左端の経路数は全て1

**時間計算量:** O(n²)
**空間計算量:** O(n²)

### 2. 最適化解法 (Dynamic Programming - 1D)
```python
def solve_optimized(n):
    # 1次元配列で空間効率を向上
    prev_row = [1] * (n + 1)

    for i in range(1, n + 1):
        curr_row = [1] * (n + 1)
        for j in range(1, n + 1):
            curr_row[j] = prev_row[j] + curr_row[j-1]
        prev_row = curr_row

    return prev_row[n]
```

**特徴:**
- 2次元配列を1次元配列2個で代替
- 前の行の情報のみを保持して空間効率を向上
- 同じ動的プログラミングの考え方を空間効率的に実装

**時間計算量:** O(n²)
**空間計算量:** O(n)

### 3. 数学的解法 (Combinatorics)
```python
def solve_mathematical(n):
    # C(2n, n) = (2n)! / (n! * n!)
    # 効率的な計算のため逐次計算
    result = 1
    for i in range(n):
        result = result * (2 * n - i) // (i + 1)

    return result
```

**特徴:**
- 組み合わせ論を使用した直接計算
- n×nグリッドの経路数は C(2n, n)
- 階乗の直接計算を避けて逐次計算で効率化

**時間計算量:** O(n)
**空間計算量:** O(1)

### 4. 階乗解法 (Mathematical - Factorial)
```python
def solve_mathematical_factorial(n):
    return math.factorial(2 * n) // (math.factorial(n) * math.factorial(n))
```

**特徴:**
- 組み合わせ数の定義通りの実装
- Python標準ライブラリの階乗関数を使用
- 理解しやすいが大きなnで効率が劣る場合がある

**時間計算量:** O(n)
**空間計算量:** O(1)

## 数学的背景

### 組み合わせ論
n×n格子の左上から右下への経路：
- **総移動回数**: 2n回（右にn回、下にn回）
- **経路数**: C(2n, n) = (2n)! / (n! × n!)
- **二項係数**: パスカルの三角形の中央値

### 格子経路の性質
1. **対称性**: 右n回、下n回の配置問題
2. **再帰関係**: path(i,j) = path(i-1,j) + path(i,j-1)
3. **境界条件**: path(0,j) = path(i,0) = 1

### 動的プログラミングの構造
```
Grid[i][j] = Grid[i-1][j] + Grid[i][j-1]

例：3×3格子の経路数計算
   0  1  2  3
0  1  1  1  1
1  1  2  3  4
2  1  3  6  10
3  1  4  10 20
```

## 具体例

### 2×2格子の全経路
経路の表記: R=右移動, D=下移動

1. RRDD (右→右→下→下)
2. RDRD (右→下→右→下)
3. RDDR (右→下→下→右)
4. DRRD (下→右→右→下)
5. DRDR (下→右→下→右)
6. DDRR (下→下→右→右)

**総経路数**: 6通り = C(4,2) = 4!/(2!×2!)

### 小さなグリッドの経路数
| Grid Size | 総移動数 | 経路数 | 二項係数 |
|-----------|----------|--------|----------|
| 1×1 | 2 | 2 | C(2,1) |
| 2×2 | 4 | 6 | C(4,2) |
| 3×3 | 6 | 20 | C(6,3) |
| 4×4 | 8 | 70 | C(8,4) |
| 5×5 | 10 | 252 | C(10,5) |
| 10×10 | 20 | 184,756 | C(20,10) |

### 実際の問題 (20×20格子)
- **総移動回数**: 40回（右に20回、下に20回）
- **経路数**: C(40,20) = [隠匿]
- **計算**: 40!/(20!×20!) = [隠匿]

## パフォーマンス比較

| 解法 | 時間計算量 | 空間計算量 | 特徴 |
|------|-----------|-----------|------|
| 素直な解法 | O(n²) | O(n²) | 理解しやすい、各段階を可視化 |
| 最適化解法 | O(n²) | O(n) | 空間効率的なDP |
| 数学的解法 | O(n) | O(1) | 最高効率、大きなnに適している |
| 階乗解法 | O(n) | O(1) | 理解しやすい、中程度のnに適している |

### 実行時間の傾向
- **小さなn (n<10)**: 全ての解法がほぼ同速
- **中程度のn (10≤n<20)**: 数学的解法が優位
- **大きなn (n≥20)**: 数学的解法が圧倒的に高速
- **メモリ制約がある場合**: 数学的解法が最適

## 学習ポイント

1. **組み合わせ論の活用**: 格子経路問題を二項係数として捉える視点
2. **動的プログラミング**: 部分問題の最適解を利用した解法構築
3. **空間効率化**: 2次元DPを1次元に圧縮する技法
4. **数値計算の工夫**: 大きな階乗の直接計算を避ける逐次計算法

## 応用と発展

### 格子経路の変種
- **障害物のある格子**: 特定の点を避ける経路数
- **重み付き格子**: 各移動にコストがある場合の最小コスト経路
- **3次元格子**: 立体格子での経路計算
- **制約付き経路**: 特定のパターンを避ける経路

### 組み合わせ論での応用
- **カタラン数**: モンテンツ経路（対角線を超えない経路）
- **デランジュマン**: 完全順列の計算
- **分割数**: 整数の分割方法の数
- **ベル数**: 集合の分割方法の数

### 実世界での応用
- **ロボット経路計画**: グリッド環境での移動経路数
- **ネットワーク信頼性**: 冗長経路の数による信頼性評価
- **確率論**: ランダムウォークの経路数計算
- **ゲーム理論**: 格子ゲームでの戦略数

## アルゴリズムの詳細

### 数学的解法の効率性
```python
# 逐次計算の詳細 (n=4の場合)
# C(8,4) = 8×7×6×5 / (4×3×2×1)

result = 1
# i=0: result = 1 × 8 ÷ 1 = 8
# i=1: result = 8 × 7 ÷ 2 = 28
# i=2: result = 28 × 6 ÷ 3 = 56
# i=3: result = 56 × 5 ÷ 4 = 70
```

### 動的プログラミングの状態遷移
```
dp[i][j] = dp[i-1][j] + dp[i][j-1]

各点での経路数は：
- 上から来る経路数 + 左から来る経路数
- 境界条件: dp[0][j] = dp[i][0] = 1
```

### 空間効率化の工夫
```python
# 2次元→1次元への変換
# 現在行の計算に必要なのは前の行のデータのみ
# O(n²) → O(n) の空間削減
```

## 関連問題
- Project Euler Problem 067: Maximum path sum II（経路問題の変種）
- Project Euler Problem 081: Path sum: two ways（最小経路和）
- Project Euler Problem 082: Path sum: three ways（3方向移動）
- Project Euler Problem 083: Path sum: four ways（4方向移動）
- Project Euler Problem 114: Counting block combinations I（制約付き配置）
