# 問題76: 和の個数

## 問題文

100を少なくとも2つの正の整数の和として表す方法は何通りあるか？

例えば、5は以下の6通りの方法で表せる：
- 4 + 1
- 3 + 2
- 3 + 1 + 1
- 2 + 2 + 1
- 2 + 1 + 1 + 1
- 1 + 1 + 1 + 1 + 1

## 数学的背景

この問題は**整数分割**（Integer Partition）として知られる組合せ論の古典的な問題です。整数分割とは、正の整数を正の整数の和として表現する方法のことです。

### 整数分割の定義

正の整数nの分割とは、n = a₁ + a₂ + ... + aₖ（ただし、a₁ ≥ a₂ ≥ ... ≥ aₖ > 0）となる正の整数の列のことです。

### 分割関数

分割関数p(n)は、正の整数nを正の整数の和として表す方法の総数を表します。問題76では、n自身だけで表す場合を除いているため、求める答えはp(100) - 1となります。

## 解法

### 1. 素直な解法：動的計画法（2次元配列）

```python
def solve_naive(n: int) -> int:
    """
    dp[i][j] = iをj以下の正の整数の和で表す方法の数
    """
    dp = [[0] * (n + 1) for _ in range(n + 1)]

    # 初期化
    for j in range(n + 1):
        dp[0][j] = 1

    # 動的計画法
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if j > i:
                dp[i][j] = dp[i][j - 1]
            else:
                dp[i][j] = dp[i][j - 1] + dp[i - j][j]

    return dp[n][n] - 1
```

**アルゴリズムの説明：**
- `dp[i][j]`は「iをj以下の正の整数の和で表す方法の数」を表す
- jを使わない場合：`dp[i][j-1]`通り
- jを使う場合：`dp[i-j][j]`通り（i-jを再びj以下で分割）
- 最終的に`dp[n][n] - 1`で、n自身のみの場合を除外

### 2. 最適化解法：動的計画法（1次元配列）

```python
def solve_optimized(n: int) -> int:
    """
    ways[i] = iを正の整数の和で表す方法の数
    """
    ways = [0] * (n + 1)
    ways[0] = 1

    for k in range(1, n):
        for i in range(k, n + 1):
            ways[i] += ways[i - k]

    return ways[n]
```

**アルゴリズムの説明：**
- `ways[i]`は「iを正の整数の和で表す方法の数」を表す
- 各数値kを使って和を作る方法を順次追加
- k = 1からn-1まで（n自身は使わない）で計算

## 計算量

### 素直な解法
- **時間計算量**: O(n²)
- **空間計算量**: O(n²)

### 最適化解法
- **時間計算量**: O(n²)
- **空間計算量**: O(n)

## 実装のポイント

1. **動的計画法の状態定義**：
   - 素直な解法では2次元の状態を持つ
   - 最適化解法では1次元に圧縮可能

2. **初期化**：
   - 0を表す方法は1通り（空の和）

3. **n自身の除外**：
   - 素直な解法では最後に1を引く
   - 最適化解法ではk < nの範囲で計算

## 検証

### 小さい値での確認

| n | 分割数 |
|---|--------|
| 2 | 1      |
| 3 | 2      |
| 4 | 4      |
| 5 | 6      |

### パフォーマンス

n = 100の場合：
- 素直な解法：約0.0008秒
- 最適化解法：約0.0002秒

## 解答

Project Euler公式サイトで確認してください。

## 学んだこと

1. **整数分割問題**の基本的な解法
2. **動的計画法**の状態設計と実装
3. **空間計算量の最適化**（2次元→1次元）
4. **組合せ論**の基礎概念
