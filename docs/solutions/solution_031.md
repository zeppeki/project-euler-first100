# Problem 031: Coin sums

## 問題

イギリスでは通貨はポンド (£) とペンス (p) で構成されています。一般に流通している硬貨は8種類あります：

1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), £2 (200p)

£2を以下の方法で作ることができます：
1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p

任意の枚数のコインを使って£2を作る方法は何通りあるでしょうか？

## 解答

Project Euler公式サイトで確認してください。

## 解法

この問題は古典的な「硬貨の組み合わせ問題」（Coin Change Problem）で、動的プログラミングの代表的な応用例です。

### 1. 素直な解法 (Naive Approach)

再帰的なアプローチを使用して、各硬貨について「使う」「使わない」の選択肢を全て試します。

**アルゴリズム：**
```python
def count_ways(amount, coin_index):
    if amount == 0:
        return 1  # 目標金額に到達
    if amount < 0 or coin_index >= len(coins):
        return 0  # 無効な状態

    # 現在のコインを使わない + 使う
    return count_ways(amount, coin_index + 1) + \
           count_ways(amount - coins[coin_index], coin_index)
```

**時間計算量:** O(8^target) - 指数的
**空間計算量:** O(target) - 再帰の深さ

この解法は理解しやすいですが、同じ部分問題を何度も計算するため非効率的です。

### 2. 最適化解法 (Optimized Approach)

動的プログラミングを使用して、重複する計算を避けます。

**アルゴリズム：**
1. `dp[i]` = 金額`i`を作る方法の数として配列を初期化
2. `dp[0] = 1`（0を作る方法は1つ：何も使わない）
3. 各硬貨について、その硬貨を使って作れる全ての金額を更新

```python
coins = [1, 2, 5, 10, 20, 50, 100, 200]
dp = [0] * (target + 1)
dp[0] = 1

for coin in coins:
    for amount in range(coin, target + 1):
        dp[amount] += dp[amount - coin]
```

**時間計算量:** O(coins × target) = O(8 × target)
**空間計算量:** O(target)

**なぜ効率的か：**
- 各部分問題を1回だけ解く
- ボトムアップ方式で計算
- メモ化により重複計算を排除

### アルゴリズムの動作例

5pを作る場合の動作を追ってみましょう：

```
初期状態: dp = [1, 0, 0, 0, 0, 0]

1pコイン処理後: dp = [1, 1, 1, 1, 1, 1]
2pコイン処理後: dp = [1, 1, 2, 2, 3, 3]
5pコイン処理後: dp = [1, 1, 2, 2, 3, 4]
```

結果：5pを作る方法は4通り
- 5p × 1
- 2p × 2 + 1p × 1
- 2p × 1 + 1p × 3
- 1p × 5

### 検証

- **入力:** 5p
- **解答:** [隠匿]
- **検証:** ✓

- **入力:** 10p
- **解答:** [隠匿]
- **検証:** ✓

- **入力:** 200p (£2)
- **解答:** [隠匿]
- **検証:** ✓

### 学習ポイント

1. **動的プログラミング**: 重複する部分問題を効率的に解決
2. **硬貨問題の定式化**: 組み合わせ問題をDPで解く標準的なパターン
3. **時間計算量の改善**: 指数的→線形への劇的な改善
4. **実用性**: 実際の決済システムでも使われる重要なアルゴリズム

この問題は動的プログラミングの威力を実感できる優秀な例題です。
