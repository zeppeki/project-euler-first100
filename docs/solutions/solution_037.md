# Problem 037: Truncatable primes

## 問題文

数3797は興味深い性質を持っています。それ自体が素数であることに加えて、左から右へと桁を連続的に除去しても各段階で素数のままです：3797, 797, 97, 7。同様に右から左へも：3797, 379, 37, 3。

左から右へと右から左へ、両方向から桁を除去しても素数のままである唯一の11個の素数の和を求めてください。

注：2, 3, 5, 7は梅切り可能素数とは考えません。

## アプローチ

### 1. 素直な解法 (solve_naive)

**基本的な考え方:**
- 11から順番に各数について梅切り素数かどうかをチェック
- 梅切り素数を11個見つけるまで続行
- 見つかった11個の和を計算

**アルゴリズム:**
1. 候補数を11から開始（2,3,5,7は除外）
2. 各候補について梅切り素数かどうか判定：
   - 数自体が素数か確認
   - 左から梅切りして全て素数か確認
   - 右から梅切りして全て素数か確認
3. 条件を満たす数を11個収集
4. 収集した数の和を計算

**時間計算量:** O(n × d × √n) where d is digits
**空間計算量:** O(1)

### 2. 最適化解法 (solve_optimized)

**改善点:**
- 梅切り素数の数字パターンの制約を利用
- 効率的な候補生成により探索空間を削減

**数学的洞察:**
- **左端の数字**: 2, 3, 5, 7のみ（素数でないと左から梅切りで合成数になる）
- **右端の数字**: 3, 7のみ（偶数で終わると左から梅切りで偶数になる）
- **中間の数字**: 1, 3, 7, 9のみ（他の数字だと梅切りで素数でなくなる）

**アルゴリズム:**
1. 2桁数から系統的に候補を生成
2. 桁数ごとに特定パターンで数を構築：
   - 左端: [2,3,5,7]
   - 中間: [1,3,7,9]の組み合わせ
   - 右端: [3,7]
3. 生成した各候補について梅切り素数か検証
4. 最初の11個の合計を計算

**時間計算量:** O(k × d × √k) where k is candidates
**空間計算量:** O(1)

## 重要な最適化

### 素数判定の効率化
```python
def is_prime(n: int) -> bool:
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    return all(n % i != 0 for i in range(3, int(n**0.5) + 1, 2))
```

### 梅切り判定
```python
def is_truncatable_prime(n: int) -> bool:
    if not is_prime(n) or n in (2, 3, 5, 7):
        return False

    s = str(n)

    # 左から梅切り
    for i in range(1, len(s)):
        if not is_prime(int(s[i:])):
            return False

    # 右から梅切り
    for i in range(len(s) - 1, 0, -1):
        if not is_prime(int(s[:i])):
            return False

    return True
```

### パターン生成
```python
# 特定のパターンで候補数を生成
for first in [2, 3, 5, 7]:
    for last in [3, 7]:
        for middle_digits in itertools.product([1, 3, 7, 9], repeat=length-2):
            candidate = construct_number(first, middle_digits, last)
```

## アルゴリズムの比較

| 解法 | 時間計算量 | 空間計算量 | 特徴 |
|------|------------|------------|------|
| 素直な解法 | O(n × d × √n) | O(1) | 順次探索 |
| 最適化解法 | O(k × d × √k) | O(1) | パターン生成による効率化 |

## 学習ポイント

1. **素数の性質**: 効率的な素数判定と素数の組み合わせ
2. **文字列操作**: 数値の桁操作と文字列スライシング
3. **数学的制約**: 問題固有の制約を活用した最適化
4. **パターン生成**: 組み合わせ論を活用した効率的な候補生成
5. **探索の枝刈り**: 不要な候補の事前除外

## 数学的洞察

### 梅切り素数の制約
- **桁数制限**: 理論上、梅切り素数は有限個（実際には11個のみ）
- **数字制限**: 使用可能な数字が大幅に制限される
- **位置制限**: 各位置で使用可能な数字が異なる

### 効率化の根拠
- 全ての梅切り素数は特定のパターンに従う
- パターン生成により候補数を指数的に削減
- 早期の素数判定により無駄な計算を回避

### 探索戦略
- 桁数を増やしながら系統的に探索
- 11個すべて発見次第終了（全探索不要）

## 実装上の注意点

- 文字列と数値の変換効率
- itertools.productの効率的な使用
- 重複候補の回避
- メモリ効率的な候補管理

## 検証

### 既知の例
- 3797: 左から→797,97,7 右から→379,37,3
- 全て素数であることを確認

### テストケース
- 一方向のみ梅切り可能: 317（右から梅切り不可：31は素数、3は素数だが1は素数でない）
- 両方向梅切り可能: 23, 37, 53, 73, 313, 317, 373, 797, 3137, 3797, 739397

### パターン検証
- 左端が偶数：不可（右から梅切りで偶数になる）
- 右端が偶数：不可（左から梅切りで偶数になる）
- 中間に0,2,4,5,6,8：不可（梅切りで合成数になる）

## 解答

Project Euler公式サイトで確認してください。

## 検証結果
- **入力:** 梅切り可能素数11個
- **解答:** [隠匿]
- **検証:** ✓ (全解法で一致)
- **該当する素数:** [隠匿]
