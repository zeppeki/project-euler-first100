# Problem 012: Highly divisible triangular number

## 問題
三角数で500個より多い約数を持つ最初の数を求めよ。

## 詳細
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
- 1: 1
- 3: 1,3
- 6: 1,2,3,6
- 10: 1,2,5,10
- 15: 1,3,5,15
- 21: 1,3,7,21
- 28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

## 解答

Project Euler公式サイトで確認してください。

## 解法

### 1. 素直な解法 (Naive Approach)
```python
def solve_naive(target_divisors):
    n = 1
    while True:
        triangular = n * (n + 1) // 2
        divisor_count = count_divisors_naive(triangular)

        if divisor_count > target_divisors:
            return triangular

        n += 1

def count_divisors_naive(num):
    count = 0
    sqrt_num = int(math.sqrt(num))

    for i in range(1, sqrt_num + 1):
        if num % i == 0:
            count += 1
            if i != num // i:  # 平方数でない場合、対応する約数も数える
                count += 1

    return count
```

**特徴:**
- 三角数を順次生成し、各数の約数を直接数える直感的なアプローチ
- √n まで調べることで約数のペアを効率的に数える
- 理解しやすく実装が簡単

**時間計算量:** O(n × √T_n) (T_nはn番目の三角数)
**空間計算量:** O(1)

### 2. 最適化解法 (Prime Factorization)
```python
def solve_optimized(target_divisors):
    n = 1
    while True:
        triangular = n * (n + 1) // 2
        divisor_count = count_divisors_optimized(triangular)

        if divisor_count > target_divisors:
            return triangular

        n += 1

def count_divisors_optimized(num):
    factors = prime_factorization(num)
    divisor_count = 1

    for exponent in factors.values():
        divisor_count *= (exponent + 1)

    return divisor_count

def prime_factorization(num):
    factors = defaultdict(int)

    # 2で割り切れる回数を数える
    while num % 2 == 0:
        factors[2] += 1
        num //= 2

    # 3以上の奇数で割り切れる回数を数える
    factor = 3
    while factor * factor <= num:
        while num % factor == 0:
            factors[factor] += 1
            num //= factor
        factor += 2

    # 残りが1より大きい場合、それも素因数
    if num > 1:
        factors[num] += 1

    return factors
```

**特徴:**
- 素因数分解を使用して約数の個数を効率的に計算
- 約数の個数 = ∏(指数 + 1) の公式を利用
- 大きな数に対して素直な解法より高速

**時間計算量:** O(n × √T_n / log(T_n))
**空間計算量:** O(log(T_n))

### 3. 数学的解法 (Triangular Number Properties)
```python
def solve_mathematical(target_divisors):
    n = 1
    while True:
        # T_n = n * (n+1) / 2
        # nとn+1は互いに素なので、約数の計算を分離できる
        if n % 2 == 0:
            # nが偶数の場合: T_n = (n/2) * (n+1)
            divisors_n_half = count_divisors_optimized(n // 2)
            divisors_n_plus_1 = count_divisors_optimized(n + 1)
            total_divisors = divisors_n_half * divisors_n_plus_1
        else:
            # nが奇数の場合: T_n = n * ((n+1)/2)
            divisors_n = count_divisors_optimized(n)
            divisors_n_plus_1_half = count_divisors_optimized((n + 1) // 2)
            total_divisors = divisors_n * divisors_n_plus_1_half

        if total_divisors > target_divisors:
            return n * (n + 1) // 2

        n += 1
```

**特徴:**
- 三角数の性質 T_n = n(n+1)/2 を活用
- gcd(n, n+1) = 1 の性質を利用して約数計算を分離
- 大きな三角数の素因数分解を避けて効率化

**時間計算量:** O(n × log(n))
**空間計算量:** O(1)

## 数学的背景

### 三角数の公式
三角数は自然数の和として定義される：
```
T_n = 1 + 2 + 3 + ... + n = n(n+1)/2
```

### 約数の個数の公式
数nの素因数分解が n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ のとき、
約数の個数は: d(n) = (a₁ + 1)(a₂ + 1)...(aₖ + 1)

### 三角数の約数の性質
T_n = n(n+1)/2 において、nとn+1は互いに素 (gcd(n, n+1) = 1) なので：

- **nが偶数の場合**: T_n = (n/2) × (n+1)
  - d(T_n) = d(n/2) × d(n+1)
- **nが奇数の場合**: T_n = n × ((n+1)/2)
  - d(T_n) = d(n) × d((n+1)/2)

## 具体例

### 最初の8個の三角数と約数
| n | T_n | 約数 | 個数 |
|---|-----|------|------|
| 1 | 1 | [1] | 1 |
| 2 | 3 | [1, 3] | 2 |
| 3 | 6 | [1, 2, 3, 6] | 4 |
| 4 | 10 | [1, 2, 5, 10] | 4 |
| 5 | 15 | [1, 3, 5, 15] | 4 |
| 6 | 21 | [1, 3, 7, 21] | 4 |
| 7 | 28 | [1, 2, 4, 7, 14, 28] | 6 |
| 8 | 36 | [1, 2, 3, 4, 6, 9, 12, 18, 36] | 9 |

### 問題例の検証 (28は5個より多い約数を持つ最初の三角数)
- T_7 = 28 = 2² × 7¹
- 約数の個数: (2+1) × (1+1) = 6個
- 約数: [1, 2, 4, 7, 14, 28]

### 実際の問題 (500個より多い約数)
- **答えの三角数**: [隠匿]
- **何番目の三角数**: [隠匿]
- **約数の個数**: [隠匿]個

## パフォーマンス比較

| 解法 | 時間計算量 | 空間計算量 | 特徴 |
|------|-----------|-----------|------|
| 素直な解法 | O(n×√T_n) | O(1) | 理解しやすい、メモリ効率的 |
| 最適化解法 | O(n×√T_n/log(T_n)) | O(log(T_n)) | 素因数分解で効率化 |
| 数学的解法 | O(n×log(n)) | O(1) | 三角数の性質を活用、最高速 |

### 実行時間の傾向
- **小さな target_divisors**: 全ての解法が高速
- **大きな target_divisors**: 数学的解法が圧倒的に有利
- **メモリ制約**: 素直な解法と数学的解法が適している

## 学習ポイント

1. **三角数の性質**: 連続する2つの数の積の半分という性質の活用
2. **約数計算の最適化**: 素因数分解を使った効率的な約数の個数計算
3. **数学的分解**: 互いに素な因数への分解による計算の簡略化
4. **アルゴリズム設計**: 問題の数学的構造を活かした効率的なアルゴリズム

## 応用と発展

### 関連する数論的概念
- **完全数**: 約数の和が自分自身の2倍になる数
- **過剰数**: 約数の和が自分自身の2倍より大きい数
- **不足数**: 約数の和が自分自身の2倍より小さい数

### 多角数の一般化
- **正方数**: n²
- **五角数**: n(3n-1)/2
- **六角数**: n(2n-1)
- **八角数**: n(3n-2)

### 計算数学への応用
- **約数関数**: σ₀(n), σ₁(n), σₖ(n)
- **メビウス関数**: μ(n)
- **オイラーのφ関数**: φ(n)

## 関連問題
- Project Euler Problem 023: 過剰数ではない正の整数の和
- Project Euler Problem 021: 友愛数
- Project Euler Problem 045: 三角数、五角数、六角数
- Project Euler Problem 179: 連続する整数と同じ数の約数を持つ数
