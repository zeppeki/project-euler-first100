# Problem 036: Double-base palindromes

## 問題文

100万未満で、10進表記でも2進表記でも回文となる数の和を求めてください。
（いずれの進数においても、回文数に先頭0を含めてはいけません）

## アプローチ

### 1. 素直な解法 (solve_naive)

**基本的な考え方:**
- 1から100万まで全ての数を順番にチェック
- 各数について10進と2進の両方で回文かどうか判定
- 両方で回文の数を合計

**アルゴリズム:**
1. 1から上限まで全ての数をループ
2. 各数を10進文字列と2進文字列に変換
3. 両方の文字列が回文かどうかをチェック
4. 条件を満たす数を合計に加算

**時間計算量:** O(n × log n)
**空間計算量:** O(log n)

### 2. 最適化解法 (solve_optimized)

**改善点:**
- 10進の回文を効率的に生成してから2進回文かチェック
- 回文の生成により探索空間を大幅に削減

**アルゴリズム:**
1. まず1桁の数（1-9）をチェック
2. 2桁以上の回文を系統的に生成：
   - 偶数桁の回文: 前半の数字を反転して後半に配置
   - 奇数桁の回文: 前半 + 中央の数字 + 前半の反転
3. 生成した各回文について2進表記で回文かチェック
4. 条件を満たす数を合計

**時間計算量:** O(√n × log n)
**空間計算量:** O(log n)

## 重要な最適化

### 回文判定の効率化
```python
def is_palindrome(s: str) -> bool:
    return s == s[::-1]
```

### 10進回文の生成
```python
# 偶数桁の回文生成
s = str(i)
palindrome_str = s + s[::-1]

# 奇数桁の回文生成
s = str(i)
palindrome_str = s + str(middle) + s[::-1]
```

### 2進変換
```python
binary_str = bin(num)[2:]  # '0b'プレフィックスを除去
```

## アルゴリズムの比較

| 解法 | 時間計算量 | 空間計算量 | 特徴 |
|------|------------|------------|------|
| 素直な解法 | O(n × log n) | O(log n) | 全数探索 |
| 最適化解法 | O(√n × log n) | O(log n) | 回文生成による効率化 |

## 学習ポイント

1. **回文の性質**: 文字列の前後を比較する効率的な判定方法
2. **数値の進数変換**: Pythonでの2進数変換とその活用
3. **回文の生成**: 数学的な規則性を利用した効率的な生成方法
4. **探索空間の削減**: 問題の性質を活用した最適化手法
5. **重複除去**: setを使用した効率的な重複管理

## 数学的洞察

### 回文の性質
- n桁の回文は最大でも10^(⌈n/2⌉)個程度
- 全数探索より効率的な生成が可能

### 2進回文の特徴
- 2進回文は比較的稀（約n/log nのオーダー）
- 10進と2進の両方で回文となる数はさらに稀

### 効率化のポイント
- 10進回文を先に生成することで候補数を大幅削減
- 重複チェックにより無駄な計算を回避

## 実装上の注意点

- 先頭0の処理（bin()関数は自動的に除去）
- 回文生成時のオーバーフロー回避
- 効率的な重複管理

## 検証

### 小さな例での確認
- 1桁: 1, 3, 5, 7, 9 （全て2進でも回文）
- 2桁: 33 （10進: 33, 2進: 100001）

### テストケース
- 10進でのみ回文: 11 （2進: 1011）
- 2進でのみ回文: 15 （2進: 1111, 10進: 15）
- 両方で回文: 33, 99, 313, 585など

## 解答

Project Euler公式サイトで確認してください。

## 検証結果
- **入力:** 100万未満の数
- **解答:** [隠匿]
- **検証:** ✓ (全解法で一致)
- **該当する数の個数:** [隠匿]個
