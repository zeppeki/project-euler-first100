# Problem 083: Path sum: four ways

## 問題の概要

左上から右下まで、上・下・左・右の4方向への移動が可能な場合の最小パス合計を求めます。これは、Problem 081（右と下のみ）とProblem 082（右、上、下）からさらに拡張された問題です。

## 解法の説明

### 1. 素直な解法 (BFS)

```python
def solve_naive(matrix: list[list[int]]) -> int:
```

- **アプローチ**: 幅優先探索（BFS）を使用
- **時間計算量**: O(4^(m*n)) - 最悪の場合
- **空間計算量**: O(m*n)

各セルまでの最短距離を記録しながら、すべての可能な経路を探索します。

### 2. 最適化解法 (Dijkstra's Algorithm)

```python
def solve_optimized(matrix: list[list[int]]) -> int:
```

- **アプローチ**: ダイクストラ法による最短経路探索
- **時間計算量**: O(m*n*log(m*n))
- **空間計算量**: O(m*n)

優先度付きキューを使用して、常に最小コストのパスから探索を進めることで効率化します。

## 数学的背景

この問題は、重み付きグラフの最短経路問題として定式化できます：
- 各セルがノード
- 隣接セルへの移動がエッジ（重みは移動先のセルの値）
- 左上から右下への最短経路を求める

4方向への移動が可能なため、負の重みがない限り、ダイクストラ法が最適です。

## 実装のポイント

1. **グラフ表現**: マトリックスを暗黙的なグラフとして扱う
2. **優先度付きキュー**: Pythonのheapqモジュールを使用
3. **訪問管理**: 各セルへの最短距離を辞書で管理
4. **早期終了**: 目的地に到達したら即座に終了

## 計算例

5×5の例題マトリックス：
```
131  673  234  103   18
201   96  342  965  150
630  803  746  422  111
537  699  497  121  956
805  732  524   37  331
```

最適経路の探索過程：
1. (0,0) = 131から開始
2. 4方向への移動を考慮しながら最短距離を更新
3. 優先度付きキューにより、常に最小コストから探索
4. 最終的に(4,4)への最短経路を発見

## パフォーマンス比較

- **BFS解法**: 小さいマトリックスでは実用的だが、大規模では遅い
- **ダイクストラ法**: 80×80のような大規模マトリックスでも高速

## 学習のポイント

1. **最短経路アルゴリズム**: ダイクストラ法の実装と応用
2. **優先度付きキュー**: 効率的な探索順序の管理
3. **グラフ理論**: マトリックスをグラフとして扱う技術
4. **問題の一般化**: 2方向→3方向→4方向への拡張

## 関連問題との比較

- **Problem 081**: 右と下のみ → 動的計画法で解ける
- **Problem 082**: 右、上、下 → 列ごとの動的計画法
- **Problem 083**: 4方向すべて → グラフ最短経路問題

## 解答

Project Euler公式サイトで確認してください。

## 検証

- **入力**: 80×80マトリックス (data/p083_matrix.txt)
- **解答**: [隠匿]
- **検証**: ✓
