# Problem 069: Totient maximum

## 問題文

オイラーのトーシェント関数 φ(n)（ファイ関数とも呼ばれる）は、n以下でnと互いに素な数の個数を求める関数です。

例えば、1, 2, 4, 5, 7, 8は全て9未満でかつ9と互いに素なので、φ(9) = 6となります。

| n | 互いに素な数 | φ(n) | n/φ(n) |
|---|-------------|------|--------|
| 2 | 1           | 1    | 2      |
| 3 | 1,2         | 2    | 1.5    |
| 4 | 1,3         | 2    | 2      |
| 5 | 1,2,3,4     | 4    | 1.25   |
| 6 | 1,5         | 2    | 3      |
| 7 | 1,2,3,4,5,6 | 6    | 1.1666...|
| 8 | 1,3,5,7     | 4    | 2      |
| 9 | 1,2,4,5,7,8 | 6    | 1.5    |
| 10| 1,3,7,9     | 4    | 2.5    |

n ≤ 10において、n = 6がn/φ(n) = 3で最大値を示すことがわかります。

n ≤ 1,000,000において、n/φ(n)が最大となるnの値を求めてください。

## 解法の概要

### アプローチ1: 素直な解法 (O(n²log n))

各数値について、1からnまでの全ての数とのGCD（最大公約数）を計算してφ(n)を求める方法です。

```python
def euler_totient_naive(n: int) -> int:
    if n <= 1:
        return 0

    count = 0
    for i in range(1, n + 1):
        if gcd(i, n) == 1:
            count += 1

    return count
```

この方法は理解しやすいですが、大きなnに対しては計算時間が膨大になります。

### アプローチ2: 最適化解法 (O(n√n))

オイラーのトーシェント関数の数学的性質を利用した効率的な計算方法です。

**数学的公式:**
```
φ(n) = n × ∏(1 - 1/p) (pはnの全ての素因数)
```

例えば、n = 12 = 2² × 3の場合：
```
φ(12) = 12 × (1 - 1/2) × (1 - 1/3) = 12 × 1/2 × 2/3 = 4
```

```python
def euler_totient_optimized(n: int) -> int:
    if n <= 1:
        return 0

    result = n
    prime_factors = get_prime_factors(n)

    for p in prime_factors:
        result = result * (p - 1) // p

    return result
```

### アプローチ3: 数学的解法 (O(π(√n)))

この問題の核心的な数学的洞察を利用した最も効率的な解法です。

**重要な洞察:**

1. **n/φ(n)の最大化条件**: n/φ(n)が大きくなるのは、φ(n)が小さいときです。

2. **φ(n)が小さくなる条件**: nが多くの異なる小さな素因数を持つときです。

3. **数学的証明**:
   ```
   n/φ(n) = n / (n × ∏(1 - 1/p)) = 1 / ∏(1 - 1/p) = ∏(p/(p-1))
   ```

4. **素因数ごとの寄与**:
   - p = 2: 2/(2-1) = 2.0
   - p = 3: 3/(3-1) = 1.5
   - p = 5: 5/(5-1) = 1.25
   - p = 7: 7/(7-1) = 1.167

小さな素数ほど比率への寄与が大きいため、**連続する小さな素数の積が最適解**となります。

```python
def solve_mathematical(limit: int) -> int:
    primes = sieve_of_eratosthenes(limit)

    product = 1
    max_n = 1

    for prime in primes:
        next_product = product * prime
        if next_product > limit:
            break
        product = next_product
        max_n = product

    return max_n
```

## 解答

Project Euler公式サイトで確認してください。

## 検証

### 小規模テスト
- **入力:** n ≤ 10
- **期待値:** 6
- **検証:** ✓ 全ての解法で一致

### 本問題
- **入力:** n ≤ 1,000,000
- **解答:** [隠匿]
- **検証:** ✓ 数学的解法による直接計算

### 素数積の分析
```
2×3×...×17 = 510,510 ≤ 1,000,000 ✓
2×3×...×19 = 9,699,690 > 1,000,000 ✗
```

したがって、最適解は 2×3×5×7×11×13×17 の積です。

## 学習ポイント

### 数論の基礎概念

1. **オイラーのトーシェント関数**:
   - 定義: φ(n) = nと互いに素な数（≤n）の個数
   - 素数pに対して: φ(p) = p - 1
   - 素数の冪に対して: φ(p^k) = p^k - p^(k-1)

2. **乗法的性質**:
   ```
   gcd(a,b) = 1 ならば φ(ab) = φ(a)φ(b)
   ```

3. **一般公式**:
   ```
   φ(n) = n × ∏(1 - 1/p) (pはnの全ての異なる素因数)
   ```

### 最適化技法

1. **数学的洞察の活用**:
   - 問題の本質を理解することで、ブルートフォースを回避
   - O(n²) → O(1) への劇的な改善

2. **素因数分解の応用**:
   - 数論関数の効率的計算
   - 既存のライブラリ関数の再利用

3. **計算量の段階的改善**:
   - 素直 → 最適化 → 数学的解法
   - 各段階での学習価値

### 実装上の工夫

1. **既存ユーティリティの活用**:
   ```python
   from problems.lib.primes import get_prime_factors, sieve_of_eratosthenes
   from problems.lib.math_utils import gcd
   ```

2. **テスト駆動開発**:
   - 小規模テストケースでの検証
   - 数学的性質の確認
   - 解法間の一貫性チェック

3. **教育的デモンストレーション**:
   - 段階的な分析表示
   - 数学的概念の視覚化
   - パフォーマンス比較

## 関連問題

- **Problem 010**: 素数の和（エラトステネスの篩）
- **Problem 021**: 親和数（約数関数）
- **Problem 070**: Totient permutation（φ(n)の応用）

## 参考文献

1. **数論の基礎**: G.H. Hardy, E.M. Wright "An Introduction to the Theory of Numbers"
2. **アルゴリズム**: Thomas H. Cormen "Introduction to Algorithms"
3. **Project Euler**: 問題69および関連する数論問題

---

*この解法は数論の美しい性質と実用的なアルゴリズムの組み合わせを示す優れた例です。*
