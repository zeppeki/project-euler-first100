# Problem 048: Self powers

## 問題

数列 $1^1 + 2^2 + 3^3 + \cdots + 10^{10} = 10405071317$ である。

$1^1 + 2^2 + 3^3 + \cdots + 1000^{1000}$ の最後の10桁を求めよ。

## 解答

Project Euler公式サイトで確認してください。

## 解法

この問題は各項が $i^i$ の形となる数列の和を求める問題である。通常の計算では数値が極めて大きくなるため、最後の10桁のみを効率的に計算する必要がある。

### 1. 素直な解法 (Direct calculation)

**アルゴリズム：**
1. 各項 $i^i$ をそのまま計算
2. すべての項を足し合わせる
3. 最後に $\mod 10^{10}$ を取って最後の10桁を取得

**時間計算量：** O(n × log n) - n項のべき乗計算
**空間計算量：** O(1)

```python
def solve_naive(limit: int = 1000) -> int:
    total = 0
    for i in range(1, limit + 1):
        total += i ** i

    # 最後の10桁を返す
    return total % 10**10
```

**特徴：**
- 実装が直感的で理解しやすい
- 大きな数の計算が必要
- メモリ使用量は少ない

### 2. 最適化解法 (Modular arithmetic)

**アルゴリズム：**
1. 各項の計算時にモジュラー算術を使用
2. $i^i \mod 10^{10}$ を計算してから加算
3. 中間結果も $\mod 10^{10}$ を取って数値を小さく保つ

**時間計算量：** O(n × log n) - modular exponentiation
**空間計算量：** O(1)

```python
def solve_optimized(limit: int = 1000) -> int:
    modulo = 10**10
    total = 0

    for i in range(1, limit + 1):
        # modular exponentiationを使ってi^i mod 10^10を計算
        power_mod = pow(i, i, modulo)
        total = (total + power_mod) % modulo

    return total
```

**特徴：**
- 各段階で数値を小さく保つ
- オーバーフローを避ける
- Python の組み込み `pow(base, exp, mod)` を活用

### 3. 数学的解法 (Mathematical optimization)

**アルゴリズム：**
1. 10の倍数の特別な性質を利用
2. $i = 10k$ の場合、$i^i = (10k)^{10k} = 10^{10k} \times k^{10k}$
3. $k \geq 1$ のとき、$10^{10k}$ により末尾10桁は0になる項を識別

**時間計算量：** O(n × log n) - 但し実際の計算量は少ない
**空間計算量：** O(1)

```python
def solve_mathematical(limit: int = 1000) -> int:
    modulo = 10**10
    total = 0

    for i in range(1, limit + 1):
        if i % 10 == 0 and i >= 10:
            # 10以上の10の倍数は末尾10桁に影響しない
            continue

        # modular exponentiationでi^i mod 10^10を計算
        power_mod = pow(i, i, modulo)
        total = (total + power_mod) % modulo

    return total
```

**特徴：**
- 無駄な計算を省略
- 数学的性質を利用した最適化
- より少ない項の計算で済む

## 数学的背景

### べき乗の性質

自己べき $i^i$ の計算における重要な性質：

1. **モジュラー算術**: $(a \times b) \mod m = ((a \mod m) \times (b \mod m)) \mod m$
2. **べき乗法則**: $a^{bc} = (a^b)^c$
3. **効率的べき乗**: $a^n \mod m$ は O(log n) で計算可能

### 10の倍数の特別な性質

$i = 10k$ （$k \geq 1$）のとき：
$$i^i = (10k)^{10k} = 10^{10k} \times k^{10k}$$

$10^{10k}$ は $k \geq 1$ で $10^{10}$ 以上の10の冪を含むため、$\mod 10^{10}$ では0になる。

### モジュラー冪乗の計算

Python の組み込み関数 `pow(base, exp, mod)` は効率的なモジュラー冪乗を提供：

```python
# 効率的: O(log exp)
result = pow(base, exp, mod)

# 非効率: O(exp)
result = (base ** exp) % mod
```

## 検証

**小さな例の確認:**
- $1^1 = 1$
- $1^1 + 2^2 = 1 + 4 = 5$
- $1^1 + 2^2 + 3^3 = 1 + 4 + 27 = 32$
- $1^1 + 2^2 + 3^3 + 4^4 = 1 + 4 + 27 + 256 = 288$

**問題例の確認:**
$1^1 + 2^2 + 3^3 + \cdots + 10^{10} = 10405071317$ ✓

**解答の検証:**
- **入力:** $1^1 + 2^2 + 3^3 + \cdots + 1000^{1000}$ の最後の10桁
- **解答:** [隠匿]
- **検証:** すべての解法が同じ結果を返す ✓

## 学習ポイント

1. **モジュラー算術**: 大きな数の計算を効率化する基本技法
2. **べき乗計算**: 効率的なアルゴリズムとPythonの組み込み関数の活用
3. **数学的最適化**: 問題の特性を利用した計算量削減
4. **数値精度**: 大きな数での正確な計算の重要性
5. **アルゴリズム比較**: 異なるアプローチの性能と精度の検証

## 実装のポイント

1. **効率的べき乗**: `pow(base, exp, mod)` の活用
2. **中間結果の管理**: 各段階でのモジュラー演算
3. **特殊ケースの処理**: 10の倍数の最適化
4. **数値範囲**: 結果が 0 ≤ result < 10^10 の範囲内であることの確認

## パフォーマンス分析

| 解法 | 時間計算量 | 特徴 |
|------|------------|------|
| 素直な解法 | O(n × log n) | 直接計算、大きな数を扱う |
| 最適化解法 | O(n × log n) | モジュラー算術、数値を小さく保つ |
| 数学的解法 | O(n × log n) | 無駄な計算を省略、さらなる最適化 |

実際の実行では、モジュラー算術を使った解法が最も効率的である。

この問題は大きな数の効率的な計算方法と、数学的性質を利用した最適化の良い例を提供している。特に、モジュラー算術の重要性と、問題の特性を理解した最適化の価値が学べる。
