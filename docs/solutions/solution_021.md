# Problem 021: Amicable Numbers

## 問題概要

真約数の和を `d(n)` で表す問題です。`d(n)` は `n` の真約数（`n` より小さく `n` を割り切る数）の和です。

### 問題文

真約数の和を `d(n)` で定義します。
- `d(a) = b` かつ `d(b) = a` で `a ≠ b` のとき、`a` と `b` は友愛数のペアと呼ばれます。

例：
- `220` の真約数: `1, 2, 4, 5, 10, 11, 20, 22, 44, 55, 110`
- `d(220) = 284`
- `284` の真約数: `1, 2, 4, 71, 142`
- `d(284) = 220`

`10,000` 未満の全ての友愛数の和を求めてください。

### 制約

- 友愛数の条件: `d(a) = b` かつ `d(b) = a` で `a ≠ b`
- 完全数（`d(n) = n`）は友愛数ではありません
- 真約数は自分自身を含まない約数です

## 解法

### 1. 素直な解法 (solve_naive)

**アプローチ**: 各数について `1` から `n-1` まで全ての数をチェックして真約数の和を計算し、友愛数の条件を満たすかを判定します。

```python
def get_proper_divisors_naive(n: int) -> int:
    if n <= 1:
        return 0

    divisor_sum = 1  # 1は常に真約数
    for i in range(2, n):
        if n % i == 0:
            divisor_sum += i

    return divisor_sum

def solve_naive(limit: int) -> int:
    amicable_sum = 0

    for a in range(2, limit):
        b = get_proper_divisors_naive(a)
        if a != b and b < limit and get_proper_divisors_naive(b) == a:
            amicable_sum += a

    return amicable_sum
```

- **時間計算量**: `O(n²)` - 各数について `O(n)` の約数計算を実行
- **空間計算量**: `O(1)`
- **特徴**: 最もシンプルで理解しやすい実装

### 2. 最適化解法 (solve_optimized)

**アプローチ**: 約数計算を平方根まで試し割りで効率化します。`i` が約数の場合、`n/i` も約数となる性質を利用します。

```python
def get_proper_divisors_optimized(n: int) -> int:
    if n <= 1:
        return 0

    divisor_sum = 1  # 1は常に真約数
    i = 2

    while i * i <= n:
        if n % i == 0:
            divisor_sum += i
            # 平方根でない場合は対応する約数も追加
            if i * i != n:
                divisor_sum += n // i
        i += 1

    return divisor_sum
```

- **時間計算量**: `O(n√n)` - 各数について `O(√n)` の約数計算
- **空間計算量**: `O(1)`
- **特徴**: 約数計算の効率化により大幅な高速化を実現

### 3. 数学的解法 (solve_mathematical)

**アプローチ**: エラトステネスの篩の考え方を応用し、全ての数の真約数の和を事前に一括計算します。

```python
def solve_mathematical(limit: int) -> int:
    # 全ての数の真約数の和を事前計算
    divisor_sums = [0] * limit

    # エラトステネスの篩的アプローチで効率的に計算
    for i in range(1, limit):
        # iを約数として持つ全ての数に加算
        for j in range(2 * i, limit, i):
            divisor_sums[j] += i

    # 友愛数を探索
    amicable_numbers = set()

    for a in range(2, limit):
        b = divisor_sums[a]
        if a != b and b < limit and divisor_sums[b] == a:
            amicable_numbers.add(a)
            amicable_numbers.add(b)

    return sum(amicable_numbers)
```

- **時間計算量**: `O(n log n)` - 調和級数により効率的な前処理
- **空間計算量**: `O(n)` - 全ての真約数の和をキャッシュ
- **特徴**: 前処理による一括計算で最高の効率を実現

## アルゴリズム解説

この問題の核心は効率的な約数計算と友愛数の判定にあります。

### 真約数計算の最適化

1. **素直な方法**: `1` から `n-1` まで全てをチェック → `O(n)`
2. **平方根最適化**: `√n` まで試し割り、対応する約数も同時に取得 → `O(√n)`
3. **エラトステネス的前処理**: 各約数から逆算して効率的に計算 → `O(log n)` 平均

### 友愛数の判定

- `d(a) = b` かつ `d(b) = a` かつ `a ≠ b` の条件をチェック
- 重複カウントを避けるため、発見済みの数を管理
- 完全数（`d(n) = n`）を適切に除外

## 実装のポイント

- **約数計算**: 平方根最適化により `O(√n)` に改善
- **重複排除**: 友愛数ペアの重複カウントを防ぐ
- **境界処理**: `1` や完全数などの特殊ケースに対応
- **効率性**: 大きな範囲での計算に対応

## パフォーマンス分析

| 解法 | 時間計算量 | 空間計算量 | 10000での実行時間 | 特徴 |
| :--- | :--- | :--- | :--- | :--- |
| 素直な解法 | `O(n²)` | `O(1)` | 約 1.5 秒 | 最もシンプル |
| 最適化解法 | `O(n√n)` | `O(1)` | 約 0.01 秒 | 約数計算効率化 |
| 数学的解法 | `O(n log n)` | `O(n)` | 約 0.003 秒 | 前処理による高速化 |

## 友愛数の性質

### 10,000未満の友愛数ペア

1. `(220, 284)` - 最初の友愛数ペア
2. `(1184, 1210)` - 2番目の友愛数ペア
3. `(2620, 2924)` - 3番目の友愛数ペア
4. `(5020, 5564)` - 4番目の友愛数ペア
5. `(6232, 6368)` - 5番目の友愛数ペア

### 数学的性質

- 友愛数は比較的稀な存在
- 完全数（`6, 28, 496, ...`）とは異なる概念
- 古代ギリシャ時代から知られている数学的概念
- 現在でも新しい友愛数ペアが発見され続けている

## 解答

Project Euler公式サイトで確認してください。

## 検証
- **入力:** 10,000未満の友愛数の和
- **解答:** [隠匿]
- **検証:** ✓
