# Problem 002: Even Fibonacci numbers

## 問題

フィボナッチ数列の項は前の2つの項の和である。最初の2項を1, 2とすれば、最初の10項は以下のようになる：

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

フィボナッチ数列の項の値が400万を超えない範囲で、偶数の項の総和を求めよ。

## 解答: 4,613,732

## 解法

### 1. 素直な解法

フィボナッチ数列を順次生成しながら、偶数の項を合計する方法です。

```python
def solve_naive(limit: int) -> int:
    if limit < 2:
        return 0
    
    a, b = 1, 2  # フィボナッチ数列の最初の2項
    total = 0
    
    while b <= limit:
        if b % 2 == 0:  # 偶数かチェック
            total += b
        a, b = b, a + b  # 次のフィボナッチ数を計算
    
    return total
```

**時間計算量**: O(n) - nはlimit以下のフィボナッチ数の個数  
**空間計算量**: O(1) - 定数個の変数のみ使用

### 2. 最適化解法

フィボナッチ数列の性質を利用して、偶数項のみを効率的に生成する方法です。

フィボナッチ数列を観察すると：
- 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...
- 偶数項: 2, 8, 34, 144, 610, ...

偶数項は3つおきに現れ、以下の漸化式が成り立ちます：
**E(n) = 4 × E(n-1) + E(n-2)**

```python
def solve_optimized(limit: int) -> int:
    if limit < 2:
        return 0
    
    # 偶数項のみを生成
    e1, e2 = 2, 8  # 最初の2つの偶数項
    total = 0
    
    # 最初の項（2）を処理
    if e1 <= limit:
        total += e1
    
    # 2番目以降の偶数項を処理
    while e2 <= limit:
        total += e2
        e1, e2 = e2, 4 * e2 + e1  # 偶数項の漸化式
    
    return total
```

**時間計算量**: O(log n) - 偶数項の個数は全体の約1/3  
**空間計算量**: O(1)

### 3. 数学的解法

フィボナッチ数列の偶数項の性質を利用した方法です。

フィボナッチ数列の偶数項は F(3), F(6), F(9), F(12), ... の形で表されます。

```python
def solve_mathematical(limit: int) -> int:
    if limit < 2:
        return 0
    
    def fibonacci(n: int) -> int:
        """n番目のフィボナッチ数を計算"""
        if n <= 0:
            return 0
        if n == 1:
            return 1
        
        # 動的計画法で計算
        a, b = 1, 1
        for _ in range(2, n):
            a, b = b, a + b
        return b
    
    total = 0
    n = 3  # 3番目から開始（最初の偶数項）
    
    while True:
        fib_n = fibonacci(n)
        if fib_n > limit:
            break
        total += fib_n
        n += 3  # 3つおきに偶数項が現れる
    
    return total
```

**時間計算量**: O(log n)  
**空間計算量**: O(1)

## 数学的背景

### フィボナッチ数列の性質

1. **偶数項の出現パターン**: フィボナッチ数列では、偶数項は3つおきに現れます
   - F(3) = 2, F(6) = 8, F(9) = 34, F(12) = 144, ...

2. **偶数項の漸化式**: 偶数項のみを考えると、以下の漸化式が成り立ちます
   - E(n) = 4 × E(n-1) + E(n-2)
   - ただし、E(1) = 2, E(2) = 8

3. **数学的証明**: 
   - F(n) = F(n-1) + F(n-2)
   - F(n+3) = F(n+2) + F(n+1) = (F(n+1) + F(n)) + F(n+1) = 2F(n+1) + F(n)
   - F(n+6) = 2F(n+4) + F(n+3) = 2(2F(n+3) + F(n+2)) + (2F(n+1) + F(n))
   - = 4F(n+3) + 2F(n+2) + 2F(n+1) + F(n) = 4F(n+3) + F(n)

## 検証

### テストケース

| Limit | Expected | Naive | Optimized | Mathematical |
|-------|----------|-------|-----------|--------------|
| 10    | 10       | ✓     | ✓         | ✓            |
| 50    | 44       | ✓     | ✓         | ✓            |
| 100   | 44       | ✓     | ✓         | ✓            |
| 400   | 188      | ✓     | ✓         | ✓            |

### 本問題の検証

- **Limit**: 4,000,000
- **解答**: 4,613,732
- **全解法一致**: ✓

## パフォーマンス比較

| 解法 | 実行時間 | 相対速度 |
|------|----------|----------|
| 素直な解法 | 0.000005秒 | 2.62x |
| 最適化解法 | 0.000002秒 | 1.00x |
| 数学的解法 | 0.000010秒 | 5.25x |

**最適化解法**が最も高速でした。これは、偶数項のみを生成するため、処理する項数が約1/3に削減されるためです。

## 最適化のポイント

1. **偶数項の性質を活用**: フィボナッチ数列の偶数項は3つおきに現れる性質を利用
2. **専用の漸化式**: 偶数項のみを生成する効率的な漸化式を使用
3. **不要な計算の削減**: 奇数項の計算を完全に省略

## 学習ポイント

1. **数列の性質の観察**: パターンを発見することで効率的な解法を導ける
2. **数学的帰納法**: 漸化式の証明には数学的帰納法が有効
3. **最適化の重要性**: 問題の特性を理解することで大幅な高速化が可能
4. **複数解法の比較**: 異なるアプローチを実装・比較することで理解が深まる

## 参考

- [Project Euler Problem 2](https://projecteuler.net/problem=2)
- [Fibonacci sequence](https://en.wikipedia.org/wiki/Fibonacci_number)
- [Even Fibonacci Numbers](https://mathworld.wolfram.com/FibonacciNumber.html) 