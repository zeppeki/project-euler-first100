#!/usr/bin/env python3
"""
Problem 012: Highly divisible triangular number

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
- 1: 1
- 3: 1,3
- 6: 1,2,3,6
- 10: 1,2,5,10
- 15: 1,3,5,15
- 21: 1,3,7,21
- 28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
"""

import math
import time
from collections import defaultdict


def solve_naive(target_divisors: int) -> int:
    """
    素直な解法: 三角数を順次生成し、各数の約数の個数を数える
    時間計算量: O(n * sqrt(T_n)) where T_n is the nth triangular number
    空間計算量: O(1)
    """
    if target_divisors < 0:
        raise ValueError("target_divisors must be non-negative")

    n = 1
    while True:
        triangular = n * (n + 1) // 2
        divisor_count = count_divisors_naive(triangular)

        if divisor_count > target_divisors:
            return triangular

        n += 1


def count_divisors_naive(num: int) -> int:
    """約数の個数を数える（素直な方法）"""
    if num <= 0:
        return 0

    count = 0
    sqrt_num = int(math.sqrt(num))

    for i in range(1, sqrt_num + 1):
        if num % i == 0:
            count += 1
            if i != num // i:  # 平方数でない場合、対応する約数も数える
                count += 1

    return count


def solve_optimized(target_divisors: int) -> int:
    """
    最適化解法: 素因数分解を使用して約数の個数を効率的に計算
    時間計算量: O(n * sqrt(T_n) / log(T_n))
    空間計算量: O(log(T_n))
    """
    if target_divisors < 0:
        raise ValueError("target_divisors must be non-negative")

    n = 1
    while True:
        triangular = n * (n + 1) // 2
        divisor_count = count_divisors_optimized(triangular)

        if divisor_count > target_divisors:
            return triangular

        n += 1


def count_divisors_optimized(num: int) -> int:
    """素因数分解を使用して約数の個数を効率的に計算"""
    if num <= 0:
        return 0

    factors = prime_factorization(num)
    divisor_count = 1

    for exponent in factors.values():
        divisor_count *= exponent + 1

    return divisor_count


def prime_factorization(num: int) -> dict[int, int]:
    """素因数分解を行い、各素因数の指数を返す"""
    factors: defaultdict[int, int] = defaultdict(int)

    # 2で割り切れる回数を数える
    while num % 2 == 0:
        factors[2] += 1
        num //= 2

    # 3以上の奇数で割り切れる回数を数える
    factor = 3
    while factor * factor <= num:
        while num % factor == 0:
            factors[factor] += 1
            num //= factor
        factor += 2

    # 残りが1より大きい場合、それも素因数
    if num > 1:
        factors[num] += 1

    return factors


def solve_mathematical(target_divisors: int) -> int:
    """
    数学的解法: 三角数の性質を利用した最適化
    T_n = n(n+1)/2 の約数の個数は、nとn+1の約数の個数から計算可能
    時間計算量: O(n * log(n))
    空間計算量: O(1)
    """
    if target_divisors < 0:
        raise ValueError("target_divisors must be non-negative")

    n = 1
    while True:
        # T_n = n * (n+1) / 2
        # nとn+1は互いに素なので、約数の計算を分離できる
        if n % 2 == 0:
            # nが偶数の場合: T_n = (n/2) * (n+1)
            divisors_n_half = count_divisors_optimized(n // 2)
            divisors_n_plus_1 = count_divisors_optimized(n + 1)
            total_divisors = divisors_n_half * divisors_n_plus_1
        else:
            # nが奇数の場合: T_n = n * ((n+1)/2)
            divisors_n = count_divisors_optimized(n)
            divisors_n_plus_1_half = count_divisors_optimized((n + 1) // 2)
            total_divisors = divisors_n * divisors_n_plus_1_half

        if total_divisors > target_divisors:
            return n * (n + 1) // 2

        n += 1


def get_triangular_number(n: int) -> int:
    """n番目の三角数を計算"""
    return n * (n + 1) // 2


def get_divisors(num: int) -> list[int]:
    """指定された数の約数をすべて取得"""
    divisors = []
    sqrt_num = int(math.sqrt(num))

    for i in range(1, sqrt_num + 1):
        if num % i == 0:
            divisors.append(i)
            if i != num // i:
                divisors.append(num // i)

    return sorted(divisors)


def test_solutions() -> None:
    """テストケースで解答を検証"""
    test_cases = [
        (0, 1),  # 0個より多い約数を持つ最初の三角数は1
        (1, 3),  # 1個より多い約数を持つ最初の三角数は3
        (2, 6),  # 2個より多い約数を持つ最初の三角数は6
        (3, 6),  # 3個より多い約数を持つ最初の三角数は6
        (4, 28),  # 4個より多い約数を持つ最初の三角数は28
        (5, 28),  # 5個より多い約数を持つ最初の三角数は28（問題例）
    ]

    print("=== テストケース ===")
    for target, expected in test_cases:
        result_naive = solve_naive(target)
        result_optimized = solve_optimized(target)
        result_math = solve_mathematical(target)

        print(f"target_divisors = {target}")
        print(f"  Expected: {expected}")
        print(f"  Naive: {result_naive} {'✓' if result_naive == expected else '✗'}")
        print(
            f"  Optimized: {result_optimized} {'✓' if result_optimized == expected else '✗'}"
        )
        print(
            f"  Mathematical: {result_math} {'✓' if result_math == expected else '✗'}"
        )

        # 約数の詳細表示（小さい数の場合）
        if expected <= 100:
            divisors = get_divisors(expected)
            print(f"  Divisors of {expected}: {divisors} (count: {len(divisors)})")
        print()


def main() -> None:
    """メイン関数"""
    target_divisors = 500

    print("=== Problem 012: Highly divisible triangular number ===")
    print(f"Finding the first triangular number with over {target_divisors} divisors")
    print()

    # テストケース
    test_solutions()

    # 本問題の解答
    print("=== 本問題の解答 ===")

    # 各解法の実行時間測定
    start_time = time.time()
    result_naive = solve_naive(target_divisors)
    naive_time = time.time() - start_time

    start_time = time.time()
    result_optimized = solve_optimized(target_divisors)
    optimized_time = time.time() - start_time

    start_time = time.time()
    result_math = solve_mathematical(target_divisors)
    math_time = time.time() - start_time

    print(f"素直な解法: {result_naive:,} (実行時間: {naive_time:.6f}秒)")
    print(f"最適化解法: {result_optimized:,} (実行時間: {optimized_time:.6f}秒)")
    print(f"数学的解法: {result_math:,} (実行時間: {math_time:.6f}秒)")
    print()

    # 結果の検証
    if result_naive == result_optimized == result_math:
        print(f"✓ 解答: {result_optimized:,}")

        # 詳細情報の表示
        n = 1
        while get_triangular_number(n) != result_optimized:
            n += 1

        divisor_count = count_divisors_optimized(result_optimized)
        print(f"この三角数は {n} 番目の三角数です")
        print(f"約数の個数: {divisor_count}")
    else:
        print("✗ 解答が一致しません")
        print(f"  Naive: {result_naive}")
        print(f"  Optimized: {result_optimized}")
        print(f"  Mathematical: {result_math}")
        return

    # パフォーマンス比較
    print("\n=== パフォーマンス比較 ===")
    fastest_time = min(naive_time, optimized_time, math_time)
    print(f"素直な解法: {naive_time / fastest_time:.2f}x")
    print(f"最適化解法: {optimized_time / fastest_time:.2f}x")
    print(f"数学的解法: {math_time / fastest_time:.2f}x")

    # 詳細な計算過程の表示
    print("\n=== 計算過程の詳細 ===")

    # 最初の10個の三角数とその約数の個数を表示
    print("最初の10個の三角数と約数の個数:")
    for i in range(1, 11):
        triangular = get_triangular_number(i)
        divisor_count = count_divisors_optimized(triangular)
        divisors = get_divisors(triangular)
        print(f"T_{i} = {triangular}, divisors: {len(divisors)} {divisors}")

    # アルゴリズムの説明
    print("\n=== アルゴリズムの説明 ===")
    print("素直な解法: 三角数を順次生成し、各数の約数を直接数える")
    print("最適化解法: 素因数分解を使用して約数の個数を効率的に計算")
    print("数学的解法: T_n = n(n+1)/2 の性質を利用してnとn+1から約数を計算")

    # 三角数の公式の説明
    print("\n三角数の公式: T_n = n(n+1)/2")
    print(f"答えの三角数 {result_optimized:,} は T_{n} です")


if __name__ == "__main__":
    main()
