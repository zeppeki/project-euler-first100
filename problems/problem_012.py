#!/usr/bin/env python3
"""
Problem 012: Highly divisible triangular number

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
- 1: 1
- 3: 1,3
- 6: 1,2,3,6
- 10: 1,2,5,10
- 15: 1,3,5,15
- 21: 1,3,7,21
- 28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
"""

import math

from .lib import count_divisors, get_triangular_number


def solve_naive(target_divisors: int) -> int:
    """
    素直な解法: 三角数を順次生成し、各数の約数の個数を数える
    時間計算量: O(n * sqrt(T_n)) where T_n is the nth triangular number
    空間計算量: O(1)
    """
    if target_divisors < 0:
        raise ValueError("target_divisors must be non-negative")

    n = 1
    while True:
        triangular = get_triangular_number(n)
        divisor_count = count_divisors(triangular)

        if divisor_count > target_divisors:
            return triangular

        n += 1


# count_divisors_naive は lib.count_divisors を使用


def solve_optimized(target_divisors: int) -> int:
    """
    最適化解法: 素因数分解を使用して約数の個数を効率的に計算
    時間計算量: O(n * sqrt(T_n) / log(T_n))
    空間計算量: O(log(T_n))
    """
    if target_divisors < 0:
        raise ValueError("target_divisors must be non-negative")

    n = 1
    while True:
        triangular = get_triangular_number(n)
        divisor_count = count_divisors(triangular)

        if divisor_count > target_divisors:
            return triangular

        n += 1


def solve_mathematical(target_divisors: int) -> int:
    """
    数学的解法: 三角数の性質を利用した最適化
    T_n = n(n+1)/2 の約数の個数は、nとn+1の約数の個数から計算可能
    時間計算量: O(n * log(n))
    空間計算量: O(1)
    """
    if target_divisors < 0:
        raise ValueError("target_divisors must be non-negative")

    n = 1
    while True:
        # T_n = n * (n+1) / 2
        # nとn+1は互いに素なので、約数の計算を分離できる
        if n % 2 == 0:
            # nが偶数の場合: T_n = (n/2) * (n+1)
            divisors_n_half = count_divisors(n // 2)
            divisors_n_plus_1 = count_divisors(n + 1)
            total_divisors = divisors_n_half * divisors_n_plus_1
        else:
            # nが奇数の場合: T_n = n * ((n+1)/2)
            divisors_n = count_divisors(n)
            divisors_n_plus_1_half = count_divisors((n + 1) // 2)
            total_divisors = divisors_n * divisors_n_plus_1_half

        if total_divisors > target_divisors:
            return get_triangular_number(n)

        n += 1


def get_divisors(num: int) -> list[int]:
    """指定された数の約数をすべて取得"""
    divisors = []
    sqrt_num = int(math.sqrt(num))

    for i in range(1, sqrt_num + 1):
        if num % i == 0:
            divisors.append(i)
            if i != num // i:
                divisors.append(num // i)

    return sorted(divisors)
