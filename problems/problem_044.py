#!/usr/bin/env python3
"""
Problem 044: Pentagon numbers

Pentagonal numbers are generated by the formula, Pn = n(3n-1)/2. So the first
ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference,
70 - 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
difference are both pentagonal and D = |Pk - Pj| is minimised; determine the
value of D.

Answer: [Hidden]
"""

import math


def generate_pentagonal(n: int) -> int:
    """
    n番目の五角数を生成
    時間計算量: O(1)
    空間計算量: O(1)
    """
    return n * (3 * n - 1) // 2


def is_pentagonal(num: int) -> bool:
    """
    数が五角数かどうか判定
    五角数の逆公式: n = (1 + sqrt(1 + 24*P)) / 6
    時間計算量: O(1)
    空間計算量: O(1)
    """
    if num <= 0:
        return False

    # 五角数の逆公式を使用
    discriminant = 1 + 24 * num
    sqrt_discriminant = int(math.sqrt(discriminant))

    # 平方根が整数でない場合
    if sqrt_discriminant * sqrt_discriminant != discriminant:
        return False

    # n = (1 + sqrt(1 + 24*P)) / 6 が正の整数かチェック
    if (1 + sqrt_discriminant) % 6 != 0:
        return False

    n = (1 + sqrt_discriminant) // 6
    return n > 0 and generate_pentagonal(n) == num


def solve_naive() -> int:
    """
    素直な解法: 五角数を順次生成して条件をチェック
    時間計算量: O(n²) - 五角数ペアの総当たり
    空間計算量: O(n) - 五角数のキャッシュ
    """
    pentagonals = []
    n = 1
    min_difference = float("inf")

    # 適当な上限まで五角数を生成
    while n <= 10000:  # 十分大きな範囲で探索
        pent = generate_pentagonal(n)
        pentagonals.append(pent)
        n += 1

        # 現在の五角数と過去の五角数の組み合わせをチェック
        for _i, prev_pent in enumerate(pentagonals[:-1]):
            current_pent = pentagonals[-1]

            # P_k > P_j の場合のみ考慮
            pk, pj = current_pent, prev_pent

            # 和と差を計算
            pent_sum = pk + pj
            pent_diff = pk - pj

            # 和と差が両方とも五角数かチェック
            if (
                is_pentagonal(pent_sum)
                and is_pentagonal(pent_diff)
                and pent_diff < min_difference
            ):
                min_difference = pent_diff

    return int(min_difference)


def solve_optimized() -> int:
    """
    最適化解法: より効率的な探索と早期終了
    時間計算量: O(n²) - 効率的な探索
    空間計算量: O(n)
    """
    pentagonals = set()
    pentagonal_list = []
    min_difference = float("inf")

    # 十分に大きな範囲で探索
    for n in range(1, 5000):
        pent = generate_pentagonal(n)
        pentagonals.add(pent)
        pentagonal_list.append(pent)

        # 現在の五角数と過去の五角数をペアでチェック
        for prev_pent in pentagonal_list[:-1]:
            pk, pj = pent, prev_pent

            pent_sum = pk + pj
            pent_diff = pk - pj

            # 差が現在の最小値より大きい場合はスキップ
            if pent_diff >= min_difference:
                continue

            # 和と差が五角数かチェック
            if is_pentagonal(pent_sum) and is_pentagonal(pent_diff):
                min_difference = pent_diff

        # 早期終了条件: 解が見つかり、かつ十分な探索を行った場合
        if min_difference != float("inf") and n > 2000 and min_difference < 10000:
            break

    if min_difference == float("inf"):
        # 解が見つからない場合はエラー
        raise ValueError("No solution found in the given range")

    return int(min_difference)


def solve_mathematical() -> int:
    """
    数学的解法: より洗練された数学的アプローチ
    時間計算量: O(n²) - 順序付け探索
    空間計算量: O(1)
    """
    min_difference = float("inf")

    # j < k の順序で探索し、より大きな範囲をカバー
    for j in range(1, 5000):
        pj = generate_pentagonal(j)

        for k in range(j + 1, 5000):
            pk = generate_pentagonal(k)

            pent_sum = pk + pj
            pent_diff = pk - pj

            # 差が現在の最小値以上なら以降の k は無意味
            if pent_diff >= min_difference:
                break

            # 和と差が五角数かチェック
            if is_pentagonal(pent_sum) and is_pentagonal(pent_diff):
                min_difference = pent_diff

        # 早期終了: 解が見つかり、jが十分大きい場合
        if min_difference != float("inf") and j > 2000 and min_difference < 10000:
            break

    if min_difference == float("inf"):
        raise ValueError("No solution found in the given range")

    return int(min_difference)
