#!/usr/bin/env python3
"""
Problem 002: Even Fibonacci numbers

Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed
four million, find the sum of the even-valued terms.

Answer: 4613732
"""

import time


def solve_naive(limit: int) -> int:
    """
    素直な解法
    フィボナッチ数列を生成しながら、偶数の項を合計

    時間計算量: O(n) - nはlimit以下のフィボナッチ数の個数
    空間計算量: O(1) - 定数個の変数のみ使用
    """
    if limit <= 0:
        return 0

    if limit < 2:
        return 0

    a, b = 1, 2  # フィボナッチ数列の最初の2項
    total = 0

    while b < limit:
        if b % 2 == 0:  # 偶数かチェック
            total += b
        a, b = b, a + b  # 次のフィボナッチ数を計算

    return total


def solve_optimized(limit: int) -> int:
    """
    最適化解法
    フィボナッチ数列の性質を利用：偶数項は3つおきに現れる

    フィボナッチ数列: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...
    偶数項: 2, 8, 34, 144, 610, ...

    偶数項のみを生成する漸化式: E(n) = 4 * E(n-1) + E(n-2)
    ただし、E(1) = 2, E(2) = 8

    時間計算量: O(log n) - 偶数項の個数は全体の約1/3
    空間計算量: O(1)
    """
    if limit <= 0:
        return 0

    if limit < 2:
        return 0

    # 偶数項のみを生成
    e1, e2 = 2, 8  # 最初の2つの偶数項
    total = 0

    # 最初の項（2）を処理
    if e1 < limit:
        total += e1

    # 2番目以降の偶数項を処理
    while e2 < limit:
        total += e2
        e1, e2 = e2, 4 * e2 + e1  # 偶数項の漸化式

    return total


def solve_mathematical(limit: int) -> int:
    """
    数学的解法
    フィボナッチ数列の偶数項の和を直接計算

    フィボナッチ数列の偶数項は: F(3), F(6), F(9), F(12), ...
    これらは F(3n) の形で表される

    時間計算量: O(log n)
    空間計算量: O(1)
    """
    if limit <= 0:
        return 0

    if limit < 2:
        return 0

    def fibonacci(n: int) -> int:
        """n番目のフィボナッチ数を計算"""
        if n <= 0:
            return 0
        if n == 1:
            return 1
        if n == 2:
            return 1

        # 動的計画法で計算
        a, b = 1, 1
        for _ in range(2, n):
            a, b = b, a + b
        return b

    total = 0
    n = 3  # 3番目から開始（最初の偶数項）

    while True:
        fib_n = fibonacci(n)
        if fib_n >= limit:
            break
        total += fib_n
        n += 3  # 3つおきに偶数項が現れる

    return total


def test_solutions() -> None:
    """テストケースで解答を検証"""
    test_cases = [
        (10, 10),  # 2 + 8 = 10
        (50, 44),  # 2 + 8 + 34 = 44
        (100, 44),  # 2 + 8 + 34 = 44
    ]

    print("=== テストケース ===")
    for limit, expected in test_cases:
        result_naive = solve_naive(limit)
        result_optimized = solve_optimized(limit)
        result_math = solve_mathematical(limit)

        print(f"Limit: {limit}")
        print(f"  Expected: {expected}")
        print(f"  Naive: {result_naive} {'✓' if result_naive == expected else '✗'}")
        print(
            f"  Optimized: {result_optimized} "
            f"{'✓' if result_optimized == expected else '✗'}"
        )
        print(
            f"  Mathematical: {result_math} {'✓' if result_math == expected else '✗'}"
        )
        print()


def main() -> None:
    """メイン関数"""
    limit = 4_000_000

    print("=== Problem 002: Even Fibonacci numbers ===")
    print(f"Limit: {limit:,}")
    print()

    # テストケース
    test_solutions()

    # 本問題の解答
    print("=== 本問題の解答 ===")

    # 素直な解法
    start_time = time.time()
    result_naive = solve_naive(limit)
    naive_time = time.time() - start_time

    # 最適化解法
    start_time = time.time()
    result_optimized = solve_optimized(limit)
    optimized_time = time.time() - start_time

    # 数学的解法
    start_time = time.time()
    result_math = solve_mathematical(limit)
    math_time = time.time() - start_time

    print(f"素直な解法: {result_naive:,} (実行時間: {naive_time:.6f}秒)")
    print(f"最適化解法: {result_optimized:,} (実行時間: {optimized_time:.6f}秒)")
    print(f"数学的解法: {result_math:,} (実行時間: {math_time:.6f}秒)")
    print()

    # 結果の検証
    if result_naive == result_optimized == result_math:
        print(f"✓ 解答: {result_optimized:,}")
    else:
        print("✗ 解答が一致しません")
        return

    # パフォーマンス比較
    print("=== パフォーマンス比較 ===")
    fastest_time = min(naive_time, optimized_time, math_time)
    print(f"素直な解法: {naive_time/fastest_time:.2f}x")
    print(f"最適化解法: {optimized_time/fastest_time:.2f}x")
    print(f"数学的解法: {math_time/fastest_time:.2f}x")


if __name__ == "__main__":
    main()
